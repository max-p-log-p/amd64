Requires GCC Version 8.3.0

Labs 4-1 and Labs 4-2 are included in Labs 4-3 and Labs 4-4

Lab 4-1
- getDispSize returns the size of the displacement using the value of the mod/rm byte

- ia32Decode checks for a prefix, then checks if an escape opcode is present which signifies a multibyte opcode. Using tthe ia32DecodeTable we can get the types of the operands. If the type is IA32_MODRM there is 1 mod/rm byte followed by a possible SIB byte and a 1 or 4 byte displacement. If the type is both IA32_MODRM and IA32_IMM8 then we perform the same step as before but add 1 for the 1 byte immediate. If the type is both IA32_MODRM and IA32_IMM32 then we perform the same step as for the IA32_MODRM but add 4 for the 4 byte immediate. If the type is IA32_IMM8 then we only add 1 to the instruction length. If the type is IA32_IMM32 then we only add 4 to the instruction length. Else, if the instruction is IA32_DATA but isn't IA32_notimpl we don't add anything since the instructions with IA32_DATA in the programs don't have a mod/rm byte. If the instruction is IA32_notimpl we manually check the opcodes and use the intel manual or the disassembly to determine the types of the operands and determine the length appropriately. It also sets the static decoded variable to the entry in ia32DecodeTable.

- StartProfiling begins with assigning the opcode to an invalid opcode to initialize it to a value that will not be considered as a IA32_RET instruction. We begin by calling ia32Decode on the function address, add the length of the instruction to get the address of the next instruction, then check if the original instruction is a IA32_RET. If the instruction is a IA32_RET we terminate, otherwise we continue to decode instructions.

Lab 4-2
- StartProfiling registers a signal handler for SIGTRAP, increments numCalls since the function has been called, and calls patchNextCtrlInstr to patch the next control instruction.

- patchNextCtrlInstr allocates memory for a IA32 instruction and enters a loop to decode each instruction using the initialized IA32Instr struct. We use the heap for a IA32 instruction since it is used as a static variable whose lifetime needs to persist beyond the end of the function. We also initialize a basicblk struct with the number of instructions set to 0 and start address set to the function address. We loop by decoding each instruction, incrementing the number of instructions in the block, and check if the instruction ia a IA32_CFLOW instruction. If it is, we terminate. Otherwise, we increment the address by the length of the instruction to get the address of the next instruction. After the loop terminates, we print out the start address and number of instructions in the block, save the original address and instruction, and patch the instruction by changing the first byte to 0xcc, which causes the kernel to send the program SIGTRAP when the instruction is executed.

- _sa_sigaction handles the SIGTRAP signal and uses the opcode in the global IA32Instr variable to determine how to handle the signal. We first unpatch the instruction by modifying the first byte from 0xcc to the original opcode of the instruction using the origAddr and instr variable which store the address and opcode of the originally patched instruction. We use the opcode to index into the ia32DecodeTable which is used as an input into to the IA32_CFLOW_TYPE macro to get the control flow type of the instruction. If the instruction is IA32_JCC then we emulate the instruction. To determine whether the instruction is executed we check whether the eflags variable obtained through the ucontext parameter passed has the correct flags set. If it does, we add the immediate in the jcc instruction to the eip register, otherwise eip is set to the next instruction. If the instruction is IA32_JMP then we set eip to the address of the next instruction plus the value of the immediate. If the instruction is IA32_CALL then we push the address of the current instruction to the stack, set eip to the value of the address calculated by the instruction, and increment the global numCalls. Otherwise, if the instruction is IA32_RET then we set eip to the current value of what is pointed to by esp, add 4 to esp, and decrement the numCalls variable. We then free the origInstr variable and set it to NULL to prevent memory leaks. If the numCalls variable is greater than 0, we patch the next control instruction using the value of eip, otherwise we stop profiling the program since we have returned from the original call to the function.
- StopProfiling sets the signal disposition to the original default, causing _sa_sigaction to no longer be called when a SIGTRAP is sent.

Lab 4-3
- In StartProfiling we allocate memory for the cache variable so that there is enough to store all of the recursive calls. Then we initialize each entry in the cache array to -1 to indicate that no result is stored in the array yet.
- In main we modify value from a local var to a global var to allow us to access it from StartProfiling. We need this so that we can determine the proper size of the cache array.
- In _sa_sigaction we modify IA32_CALL so that the input is set to the first stack parameter which is the argument to the function. We check if the return value for the call is already stored in the array, if it is we set eax to the return value and set eip to the next instruction. Otherwise, we proceed as previously defined. We also modify IA32_RET to make the return value be stored in the cache variable by setting the input to *(esp + 4) since at that point of execution *esp points to the return address and *(esp + 4) points to the first parameter to the function. Then we use input to index into the cache array and store the value of eax.
- In StopProfiling we also free the memory allocated for the cache variable and set it to NULL.

Lab4-4
- Same as Lab4-2 but added check for REX prefix, renamed ia32DecodeTable to amd64DecodeTable, ia32Decode to amd64Decode, , changed variable sizes to uint64_t in _sig_sigaction, changed IA32Instr to AMD64Instr
